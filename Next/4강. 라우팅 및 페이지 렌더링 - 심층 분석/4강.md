## 병렬 라우트 설정 및 사용

### 병렬 라우트

- 병렬 라우트는 별도의 경로를 가지는 라우트 두 개의 콘텐츠를 동일한 페이지에서 렌더링하는 기능이다.
- 이를 설정하기 위해서는 병렬 라우트를 포함하려는 경로에 레이아웃 파일을 추가해야 한다. 또한 병렬 라우트마다 하위 폴더 하나를 추가해야 한다.
- 병렬 라우트를 추가하려면 @ 기호로 시작하는 폴더를 추가하면 된다. 이는 병렬 라우트 명명 규칙이다.
- 해당 경로로 폴더를 추가하면 layout.js에는 props로 @ 기호 뒤에 있는 명칭을 받을 수 있게 된다. 만약 `@archive` 를 추가하였다면 layout.js에는 archive 를 받을 수 있는 것이다.

```
app
  - archive
    -  @archive
    -  @latest
```

#### 주의사항

- 동일한 페이지에 표시되는 병렬 라우트는 전부 원하는 경로를 모두 지원해야 한다. 예를 들면 `@archive`에 `[year]` 이라는 동적 라우트를 추가하였다면 `@latest` 에도 똑같이 뒤의 라우팅을 지원해야 한다.
- 그렇지만 그런 동적 라우트가 필요하지 않을 시에는 `default.js` 파일을 추가한다.

### default.js

- `default.js` 파일은 표시할 기본 폴백 콘텐츠를 정의하도록 허용하는 파일이다.
- 따라서 라우트가 현재 로딩된 경로에 대해 더 구체적인 콘텐츠를 가지고 있지 않을 시에 출력이 된다.
- 만약 `page.js` 와 `default.js` 가 동일한 파일 구성을 가지고 있다면 `page.js` 를 지우고 `default.js` 만을 남겨둘 수도 있다.

## Catch-All 라우트

- catch-all 라우트를 사용하기 위해서는 대괄호를 두개를 사용하며 내부에 명칭 앞에 `...`을 붙인다.
  - ex) `[[...filter]`
- 이 폴더는 상위의 모든 경로 세그먼트에 대해 활성화되도록 보장하는 것이다.
- 해당 폴더에서 url 값은 대괄호가 한 개 일 때와는 다르게 단일 값이 아닌 모든 경로 세그먼트를 캐치하기 때문에 배열을 받는다.

## 인터셉팅 라우트

### 인터셉팅 라우트

- 인터셉팅 라우트는 대체 라우트로 페이지 내부 링크를 통한 탐색 여부에 따라 때때로 활성화된다. 단일 페이지 애플리케이션 모드로 페이지에서 탐색하는지 외부 링크를 통해 접근하는지 URL을 직접 입력하는지 페이지를 새로 고침 하는지 등 같은 경로더라도 접근 방법에 따라 표시되는 페이지가 달라진다.
- 인터셉팅 라우트는 기본적으로 내부 내비게이션 요청을 가로챈다.
- 인터셉팅 라우트는 가로챌 페이지의 형제 폴더로 `()` 소괄호를 작성하고 가로챌 라우트의 이름을 뒤에 작성한다.
- 괄호 사이에는 이 폴더로부터의 경로와 대표하는 경로 세그먼트 가로챌 세그먼트를 설명해야 한다. 이름이 같더라도 관련 폴더에 도달하는 경로를 설명해야 한다. 마치 import 처럼 사용하고 싶은 것들의 경로를 작성하는 것과 비슷하다.
- 다음으로는 해당 폴더 내에 page.js 를 작성하고 내비게이션 요청을 가로챌 경우 보여 줄 페이지를 정의한다.

```
- news
	- image
		- page.js
	- (.)image
		- page.js
```

### 병렬 및 인터셉트 라우트 결합하기

- 병렬 라우트 밑에 인터셉트 라우트 폴더를 넣으면 경로는 바뀌지 않는다. 왜냐하면 병렬 라우트 폴더는 무시하 때문이다.

## 프로그램 방식으로 탐색하기

### 페이지 이동

- 페이지를 프로그램 방식으로 이동하려면 `import {useRouter} from "next/navigation";` 를 통해 `useRouter` 를 import 한다.
- 다음으로 useRouter를 선언하고 메서드를 사용한다.
  - `push` : 페이지 스택에 새 페이지를 넣는다.
  - `refresh` : 페이지를 수동으로 새로 고침 한다.
  - `back` : 페이지를 뒤로 이동한다.
  - `foward` : 페이지를 앞으로 이동한다.

```
import { useRouter } from "next/navigation";

const router = useRouter();
router.back();
```

## 라우트 그룹

### 라우트 그룹

- 라우트 그룹을 생성하면 생기는 이점은 라우트 그룹을 통해 전용 레이아웃을 설정할 수 있다.
- 라우트 그룹을 사용하기 위해서는 폴더 명을 소괄호 내에 이름을 작성하는 방식으로 설정한다.
- 라우트 그룹을 설정하면 찾을 수 없는 페이지를 비롯해 다른 페이지는 라우트 그룹과 같은 수준에 둘 수 없다.

```
- (content)
	- archive
	- news
	- layout.js
	- not-found.js
- (marketing)
	- layout.js
	- page.js
- globals.css
- icon.png
```

## 라우트 핸들러

### 라우트 핸들러

- app 폴더에 api 폴더를 만들고 내부에 `route.js` 를 생성한다. `route.js` 파일을 생성하면 페이지와는 다른 라우트 핸들러를 설정해야 한다.
- 라우트 핸들러란 다양한 함수를 내보내는 파일이다. HTTP 메서드의 이름인 GET과 POST, PATCH, PUT, DELETE 등이 있다.
- 라우트 핸들러의 핵심은 화면에 렌더링되는 페이지를 반환하지 않는 라우트를 설정하는 것이다. 대신 라우트 핸들러에서는 보통 JSON 데이터를 반환하거나 수신되는 JSON 데이터를 수락하고 JSON 응답을 반환한다.
- 따라서 라우트 핸들러의 목적은 API 같은 라우트를 설정하여 데이터를 생성, 저장하는 등 필요한 작업을 전부 수행하되 클라이언트에서 내부적으로 호출하는 것이다. 전체 페이지 콘텐츠를 렌더링하는 것이 아니라 내부적으로 일부 데이터만 저장할 수 있게끔 동작하는 것이다.
- 동일한 파일에 라우트 핸들러를 여러 개 설정해서 같은 경로 내 다양한 요청을 처리할 수 있다.
- 이런 라우트 핸들러는 NextJS에 의해 자동으로 요청 객체를 받고 Response 클래스를 이용한 객체를 반환한다.

```
app/api/route.js

export function GET(request) {
  console.log(request);

  // return Response.json();
  return new Response("Hello!");
}
```

## 미들웨어

### 미들웨어

- 미들웨어는 app 폴더를 사용하지 않는다. 미들웨어를 사용하기 위해서는 최상위 디렉토리로 이동 후 package.json을 비롯한 파일 옆에 `middleware.js` 파일을 추가한다.
- 다음으로 `middleware` 라는 함수를 export 하는데 해당 함수는 NextJS가 자동으로 전달하는 요청 객체를 받는다. 이후 `NextResponse` 를 반환해야 한다. `import { NextResponse } from "next/server"` 를 통해 import 한다.
- `NextResponse` 는 다양한 메서드를 호출하며 인스턴스화하면 아예 새로운 응답을 생성할 수 있고 next 같은 유틸리티 메서드를 사용해 들어오는 요청을 실제 대상으로 전달하기도 한다.
- middleware 함수의 목적은 수신하는 요청을 차단하거나 처리할 수 있으나 수신하는 요청을 살펴보고 변경하거나 차단해서 인증을 구현하고 사용자가 인증되지 않았으면 다른 페이지로 리디렉션하는 것이다.
- 미들웨어는 페이지, 라우트 등 전체 웹사이트로 전송된 요청에서 실행할 코드를 설정하도록 허용한다. 따라서 해당 요청 블록을 검사하거나 리디렉션할 수 있다.
- 미들웨어는 config라는 객체를 내보낼 수 있는데 여기에서 `matcher` 프로퍼티를 설정할 수 있다. 미들웨어를 트리거하는 요청을 필터링하도록 한다.

```
root 폴더/middleware.js

import { NextResponse } from "next/server"

export function middleware(request) {
  console.log(request);
  return NextResponse.next();
}

export const config = {
  matcher: "/news",
};
```
