## NextJS의 캐싱 유형 이해하기

- NextJS는 상당히 공격적인 캐싱을 수행한다. 정확하게는 네 가지 다른 영역에서 데이터나 페이지를 캐싱한다.
- **요청 기억**은 동일한 설정을 가진 데이터 요청을 저장하여 중복 요청을 방지한다는 의미이다. 이 요청 기억은 NextJS 서버에서 처리되는 단일 요청 동안에만 발생한다.
- **데이터 캐시**는 데이터 소스에서 변경되지 않은 경우 데이터를 저장하고 재사용하는 것에 관한 것이다. 이 데이터 캐시의 목적은 중복 요청을 줄이거나 방지하는 것이 아닌 데이터가 변경되지 않는 한 요청 자체를 완전히 피하는 것이다. 또한 데이터 캐시는 사용자가 수동으로 검증할 때까지 지속된다.
- **라우트 캐시**는 전체 페이지, 전체 HTML 코드 및 전체 React 서버 컴포넌트 페이로드를 내부적으로 관리하고 이를 사용하여 해당 페이지들을 렌더링한다는 것이다. 따라서 단지 데이터 소스로의 추가적인 왕복을 피하는 뿐만 아니라 전체 HTML 페이지가 다시 렌더링하는 것을 완전히 피하게 된다. 이 캐시는 관련 데이터 캐시가 재검증될 때까지 지속되며 업데이트된 데이터가 있을 때만 페이지가 재랜더링 된다.
- **라우터 캐시**는 앞의 세 가지 캐시들과는 다르게 클라이언트 측에서 관리되는 캐시이다. NextJS는 브라우저의 메모리에 일부 React 서버 컴포넌트 페이로드를 저장하여 페이지 간의 이동이 더 빨리 일어날 수 있도록 한다. 이 캐시는 서버에 의해 새로운 페이지가 렌더링 될 때 또는 NextJF로 렌더링 된 웹사이트를 벗어났다가 다시 돌아올 때 무효화 된다.

### 요청 메모화 처리

- 요청 기억은 동일한 api 요청이 있었을 때 캐싱 처리가 된다. 헤더나 api 주소가 완전하게 동일해야 한다.
- 두 요청이 정확히 같은 구성을 가질 때 NextJS는 불필요한 요청을 피하고 대신 하나의 요청만 보내고 필요한 응답을 애플리케이션의 모든 부분에서 재사용한다.

### 데이터 캐시 및 캐시 설정

- 데이터 캐시는 백엔드에서 데이터를 가져오는 fetch 함수를 사용할 때 응답 데이터를 내부적으로 관리되는 서버 측 캐시에 저장하고 계속해서 그 데이터를 재사용한다. 사용자가 더 이상 재사용하지 말라고 지시할 때까지 계속 그렇게 한다.
- 이러한 재사용을 막기 위해서는 `revalidatePath()` 를 이용한다.
- 이에 대한 대안으로 fetch 함수를 구성할 수도 있다. 구성 객체를 추가하고 그 객체에서 cache 설정을 하면 된다.
- `cache` 설정은 기본적으로 설정된 `force-cache`가 있고 이는 NextJs에게 데이터가 가능한 한 캐시되어 재사용되도록 지시한다.
- `no-store` 옵션은 NextJS에게 화면에 보이는 fetch 요청에 대해 동일한 요청이 보내지는 다른 위치가 아닌 바로 이곳에서 보내지는 요청의 데이터가 캐시되지 않아야 한다고 알려준다.

```
const response = await fetch("http://localhost:8080/messages", {
    cache: "no-store",
});
```

- 또 다른 방법으로는 객체에 `cache`설정이 아니라 NextJS 애플리케이션에서 fetch 함수를 사용할 때 쓸 수 있는 `next` 설정으로 구성한다.
- `next` 설정에서 객체를 전달하는데 거기서 `revalidate` 옵션을 추가한다. 해당 옵션은 숫자를 전달하는데 이 숫자는 NextJS가 캐시 데이터를 재사용해야 할 초 수 이다. 해당 초가 지나면 캐시는 데이터를 삭제하고 다시 데이터를 불러온다.
- `revalidate` 설정을 추가하는 것은 우아한 방식으로 일부 캐싱 이점을 얻으면서 데이터를 영구적으로 캐싱하지 않는다.

### 데이터 캐싱 제어

- 위에서 설명한 api나 함수 사용 대신에는 페이지 전체에서 설정을 할 수 있는데 두 가지 상수로 설정할 수 있다.

#### revalidate 상수

- 이 상수는 데이터 캐싱을 fetch 함수에서 설정하는 방식과 동일한 목적을 가진다.
- 해당 상수에 숫자를 지정하면 해당 숫자의 초 동안 데이터가 캐시되어 재사용되고 새로운 요청이 전송될 때까 기다린다.
- NextJS가 해당 상루를 인식하려면 반드시 이를 export 해야하면 또한 `revalidate`라는 이름을 사용해야 한다.

#### dynamic 상수

- 이 상수는 다양한 값을 가질 수 있으며, 기본값은 auto 이다. 이를 `force-dynamic`으로 설정할 수 있다.
- `force-dynamic`은 파일 내 어디에서든 필요한 모든 데이터를 항상 다시 가져오도록 지시한다.
- 또는 `force-static`으로 설정하여 캐싱을 강제할 수도 있지만 이 경우 새로운 데이터를 전혀 가져오지 않는다.

#### unstable-noStore 함수

- `import { unstable_noStore } from 'next/cache';`를 import 한다.
- 해당 함수는 `force-dynamic` 설정을 사용하는 것보다 권장되는 방법이다.
- 이는 특정 컴포넌트에 해당 함수를 적용함으로써 캐싱 문제를 해결할 수 있다. 컴포넌트 내부에 `unstable_noStore();` 함수만 사용함으로써 적용이 가능하다.

### 전체 라우트 캐시

- 전체 라우트 캐시는 빌드 시 이미 생성되고 초기화되는데 빌드 시 미리 렌더링 되고 캐시된 페이지이기 때문에 페이지를 얼마나 자주 새로고침하거나 다른 곳으로 이동한 후 다시 돌아올 때도 캐싱된 페이지를 제공하기 때문이다.
- 이를 해결하기 위해서는 데이터 캐싱에서 해결한 문제를 사용하면 된다.

#### revalidatePath

- `import {revalidatePath } from 'next/cache';`
- `revalidatePath`는 캐시된 데이터를 제거하는 또 다른 방법이다. 이는 NextJS에 지시하여 필요할 때 특정 캐 부분을 재검증한다. 이 방법은 캐시를 영구적으로 비활성화하거나 캐싱에 대한 시간을 설정하는 것보다 효율적일 수 있다.
- 주요 사용 방법은 경로를 설정하는 것이다. 하지만 중요한 점으로 중첩된 경로와 중첩된 페이지들은 데이터와 라우트 캐시가 삭제되거나 재검증되지 않는다는 것이다.
- 따라서 두 번째 인수를 `layout`으로 설정하면 NextJS에 이 경로의 캐시를 재검증하고 모든 중첩된 페이지의 캐시도 재검증하라고 명시적으로 지시하는 것이다.

#### revalidateTag

- `import {revalidateTag } from 'next/cache';`
- `revalidateTag`는 msg 같은 태그를 입력으로 받는다. 이 함수를 사용하기 위해서는 데이터를 가져올 때 캐시될 데이터에 요청을 보내는 시점에서 태그를 할당할 수 있게 한다. fetch의 두 번째 인수로써 객체를 추가하고 그 객체 내부에 `next` 설정을 추가한다. 해당 `next`설정 내부에는 `tags` 를 또 설정할 수 있는데 거기에서 태그 명을 작성하면 캐시된 데이터에 연결되는 것이다.

```
import { revalidateTag } from "next/cache";

const response = await fetch("http://localhost:8080/messages", {
    next: { tags: ["msg"] },
});

revalidateTag('msg');
```

- 이 함수를 통해 태그가 설정된 데이터들은 캐시를 다 방면의 페이지에서 지울 수 있게 된다.

### 커스텀 데이터 소스에 대한 요청 메모화 설정

- 사용자가 설정한 데이터를 함수를 통해 가져올 때는 캐싱이 진행되지 않는다.
- 이를 해결하기 위해서는 React에서 제공하는 `cache` 함수를 사용한다.
- 이 `cache` 함수는 중복 요청 제거가 발생해야 하는 함수를 감싸는 데 사용이 된다.

```
import { cache } from "react";

export const getMessages = cache(function getMessages() {
  console.log("Fetching messages from db");
  return db.prepare("SELECT * FROM messages").all();
});
```

- 이렇게 함으로써 함수가 전달하는 데이터는 리액트에서 캐싱이 진행된다.

### 커스텀 데이터 소스에 대한 데이터 캐싱 설정

- `import { unstable_cache } from 'next/cache';` 를 통해서 `unstable_cache` 함수를 불러온다.
- 이 함수는 React가 제공하는 cache 함수를 사용했던 것과 비슷한 방식으로 사용한다.

```
import { unstable_cache } from "next/cache";

export const getMessages = unstable_cache(
  cache(function getMessages() {
    console.log("Fetching messages from db");
    return db.prepare("SELECT * FROM messages").all();
  }), ['messages'], { tags: ['msg'] }
);
```

- 해당 함수는 데이터 캐싱을 진행하고 return 값이 프로미스를 반환하기 때문에 async 및 await 키워드를 사용해야 한다.
- 이 함수는 두 번째 인자를 가지고 있는데 이 인자는 키 값으로 내부적으로 캐시된 데이터를 식별하는 데 사용이 된다. **하지만 위에서 설명한 할당할 수 있는 태그와 혼동해서는 안된다.**
- 마지막으로 세 번째 인자로 객체에서 설정 값을 작성하는데 `revalidate` 값, `tags` 등이 있다. 거기서 `tags`를 이용하여 `revalidateTag` 함수를 사용할 수 있다.

### 커스텀 데이터 소스 데이터 무효화

- 커스텀 데이터 캐싱을 무효화 하기 위해서는 두 가지 방법이 있다.
- `revalidatePath` 함수를 호출하거나 `revalidateTag` 를 사용한다.
